<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Manifest file -->
<link rel="manifest" href="manifest.json" />

<!-- Icons for browser tabs and homescreens -->
<link rel="icon" type="image/png" sizes="192x192" href="icon-192.png" />
<link rel="apple-touch-icon" href="icon-192.png" />

<!-- Meta tags for theme color and mobile -->
<meta name="theme-color" content="#0a0a12" />
<meta name="mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Neon Reaction Trainer (Android Portrait)</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0a12; --panel:#10101a; --accent:#00fff7; --accent-2:#00ff88;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    font-family: 'Orbitron', monospace;
    -webkit-user-select:none; user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  /* Portrait constraint */
  #app{
    width:100vw;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    overflow:hidden;
  }

  /* Game Area (portrait) */
  #game-wrap{
    position:relative;
    width:100%;
    height:100%;
    max-width:420px; /* phone narrow width */
    aspect-ratio: 9/16;
    background:linear-gradient(180deg,#0c0c12 0%, #06060a 100%);
    border-radius:14px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 0 40px rgba(0,255,255,0.02);
    overflow:hidden;
    touch-action: none; /* prevent browser gestures */
  }

  /* Canvas for particles */
  #particle-canvas{
    position:absolute; inset:0; width:100%; height:100%; z-index:0; pointer-events:none;
  }

  /* HUD (top bar) */
  #hud{
    position:absolute; top:6px; left:6px; right:6px; height:48px; z-index:30;
    display:flex; align-items:center; justify-content:space-between; gap:6px;
    padding:6px 8px;
    pointer-events:none;
  }
  .hud-block{
    min-width:0;
    display:flex; align-items:center; gap:8px; padding:6px 10px; border-radius:10px;
    background:linear-gradient(90deg, rgba(0,0,0,0.25), rgba(255,255,255,0.02));
    color:var(--accent);
    text-shadow: 0 0 6px var(--accent);
    font-size:13px;
    pointer-events: all; /* Make HUD blocks clickable */
  }
  .hud-center { justify-content:center; pointer-events:all; }

  .hud-label { font-size:11px; color: rgba(0,255,255,0.75); }
  .hud-value { font-size:16px; font-weight:700; }

  /* New return button style */
  #return-btn {
    pointer-events: all;
    cursor: pointer;
    background: rgba(0,0,0,0.25);
    color: var(--accent);
    border: none;
    padding: 6px 10px;
    border-radius: 10px;
    font-size: 13px;
    font-family: 'Orbitron', monospace;
    text-shadow: 0 0 6px var(--accent);
    /* NEW: Position at the bottom-right */
    position: absolute;
    bottom: 10px;
    right: 10px;
    z-index: 50;
  }

  /* Game area where circles spawn */
  #play-area{
    position:absolute;
    top:60px; bottom:10px; left:8px; right:8px;
    border-radius:10px;
    z-index:2;
    overflow:hidden;
  }

  .circle {
    position:absolute;
    width:56px; height:56px; /* mobile-friendly size */
    border-radius:50%;
    background: radial-gradient(circle at center, var(--accent), #004444 70%);
    box-shadow: 0 0 12px var(--accent), 0 0 28px var(--accent-2);
    z-index:20;
    display:flex; align-items:center; justify-content:center;
    touch-action: none;
    -webkit-user-select:none; user-select:none;
  }

  .circle:active { transform: scale(0.9); transition: transform 60ms; }

  /* Start / overlays */
  .overlay {
    position:absolute; inset:0; z-index:50; display:flex; align-items:center; justify-content:center;
    background: linear-gradient(180deg, rgba(2,6,8,0.4), rgba(2,6,8,0.6));
    backdrop-filter: blur(4px);
  }
  .panel{
    width:86%; max-width:360px; background: linear-gradient(180deg,#071018, #051018);
    border-radius:14px; padding:16px; text-align:center; box-shadow: 0 10px 40px rgba(0,0,0,0.6);
    border: 1px solid rgba(0,255,255,0.06);
  }
  .title{
    color:var(--accent); font-size:22px; margin:6px 0 12px; text-shadow: 0 0 8px var(--accent);
  }
  .subtitle { color: rgba(0,255,255,0.65); font-size:12px; margin-bottom:8px; }

  .btn{
    display:inline-block; margin:6px; padding:10px 14px; border-radius:10px; font-weight:700;
    background:var(--accent); color:#022; cursor:pointer; border:none; font-size:14px;
    box-shadow: 0 6px 18px rgba(0,255,255,0.08);
  }
  .btn.ghost { background:transparent; color:var(--accent); border:1px solid rgba(0,255,255,0.08); }
  .btn.small { padding:8px 10px; font-size:13px; }

  .difficulty-row { display:flex; justify-content:center; gap:8px; margin:8px 0 10px; }

  /* Countdown big text */
  #countdown-text{
    position:absolute; inset:0; z-index:40; display:flex; align-items:center; justify-content:center;
    font-size:72px; color:var(--accent); text-shadow: 0 0 30px var(--accent);
    pointer-events:none;
  }

  /* Game Over */
  #gameover-panel .panel { max-width:320px; }

  /* small responsive tweaks */
  @media (max-width:360px){
    .circle { width:50px; height:50px; }
    #countdown-text { font-size:58px; }
  }
</style>
</head>
<body>
<div id="app">
  <div id="game-wrap" role="application" aria-label="Neon Reaction Trainer">
    <canvas id="particle-canvas"></canvas>

    <div id="hud">
      <div class="hud-block" style="pointer-events:none">
        <div>
          <div class="hud-label">SCORE</div>
          <div id="score" class="hud-value">0</div>
        </div>
      </div>
      <div class="hud-block hud-center" style="min-width:110px;">
        <div style="text-align:center;">
          <div class="hud-label">COMBO</div>
          <div id="combo" class="hud-value">x1</div>
        </div>
      </div>
      <div class="hud-block" style="text-align:right;">
        <div>
          <div class="hud-label">RT / AVG</div>
          <div id="rt" class="hud-value">-- / --</div>
          <div style="font-size:10px; color:rgba(0,255,255,0.6); margin-top:4px;" id="best-line">BEST: --</div>
        </div>
      </div>
    </div>
    <button id="return-btn" class="btn ghost small">MENU</button>

    <div id="play-area"></div>

    <div id="countdown-text" style="display:none">3</div>

    <div id="loading-overlay" class="overlay">
      <div class="panel">
        <div class="title">NEON REACTION TRAINER</div>
        <div class="subtitle">Tap the circles as fast as you can. Faster taps build combos!</div>

        <div class="difficulty-row" aria-hidden="false">
          <button class="btn ghost small" data-diff="easy">Easy</button>
          <button class="btn small" data-diff="medium" style="background:var(--accent-2); color:#002">Medium</button>
          <button class="btn ghost small" data-diff="hard">Hard</button>
        </div>

        <div style="margin:10px 0;">
          <button id="start-btn" class="btn" aria-label="Start Game">START</button>
        </div>
        <div style="margin-top:8px; font-size:12px; color:rgba(0,255,255,0.6);">Immersive full-screen will be requested on start.</div>
      </div>
    </div>

    <div id="gameover-overlay" class="overlay" style="display:none;">
      <div id="gameover-panel" class="panel">
        <div class="title">GAME OVER</div>
        <div id="final-stats" style="color:var(--accent); font-size:15px; margin:8px 0;">
          </div>
        <div style="margin-top:10px;">
          <button id="restart-btn" class="btn">Restart</button>
          <button id="back-btn" class="btn ghost">Difficulty</button>
        </div>
      </div>
    </div>

  </div>
</div>

<script>
  
  if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(reg => console.log('Service Worker registered.', reg))
      .catch(err => console.log('Service Worker registration failed:', err));
  });
}
/* ========== Setup Canvas Particles ========== */
const canvas = document.getElementById('particle-canvas');
const ctx = canvas.getContext('2d');
const gameWrap = document.getElementById('game-wrap');
const playArea = document.getElementById('play-area');

function resizeCanvas(){ canvas.width = gameWrap.clientWidth; canvas.height = gameWrap.clientHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

class BgParticle {
  constructor(){
    this.reset();
  }
  reset(){
    this.x = Math.random()*canvas.width;
    this.y = Math.random()*canvas.height;
    this.r = Math.random()*1.6 + 0.5;
    this.speedX = (Math.random()-0.5)*0.25;
    this.speedY = (Math.random()-0.5)*0.25;
    this.alpha = Math.random()*0.5 + 0.2;
  }
  update(){
    this.x += this.speedX;
    this.y += this.speedY;
    if(this.x < 0) this.x = canvas.width;
    if(this.x > canvas.width) this.x = 0;
    if(this.y < 0) this.y = canvas.height;
    if(this.y > canvas.height) this.y = 0;
  }
  draw(){
    ctx.beginPath();
    ctx.shadowBlur = 12;
    ctx.shadowColor = '#00fff7';
    ctx.fillStyle = `rgba(0,255,255,${this.alpha})`;
    ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
    ctx.fill();
  }
}
let bgParticles = [];
for(let i=0;i<90;i++) bgParticles.push(new BgParticle());

/* Burst particles for click */
class BurstParticle {
  constructor(x,y,color){
    this.x=x; this.y=y; this.size=Math.random()*3+1;
    const ang = Math.random()*Math.PI*2; const s = Math.random()*5+1;
    this.vx = Math.cos(ang)*s; this.vy = Math.sin(ang)*s;
    this.alpha=1; this.decay=0.06+Math.random()*0.04; this.color=color;
  }
  update(){
    this.x+=this.vx; this.y+=this.vy; this.alpha-=this.decay;
  }
  draw(){
    if(this.alpha<=0) return;
    ctx.beginPath();
    ctx.shadowBlur = 12;
    ctx.shadowColor = this.color;
    ctx.fillStyle = this.color.replace(')', `,${this.alpha})`).replace('rgb','rgba');
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
  }
}
let bursts = [];

function animate(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  bgParticles.forEach(p=>{ p.update(); p.draw(); });
  bursts.forEach(b=>b.update());
  bursts = bursts.filter(b=>b.alpha>0);
  bursts.forEach(b=>b.draw());
  requestAnimationFrame(animate);
}
animate();

/* ======= Game Variables & UI ======= */
const loadingOverlay = document.getElementById('loading-overlay');
const gameoverOverlay = document.getElementById('gameover-overlay');
const startBtn = document.getElementById('start-btn');
const restartBtn = document.getElementById('restart-btn');
const backBtn = document.getElementById('back-btn');
const returnBtn = document.getElementById('return-btn');
const countdownText = document.getElementById('countdown-text');
const difficultyRow = document.querySelector('.difficulty-row');

const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const rtEl = document.getElementById('rt');
const bestLine = document.getElementById('best-line');

let score = 0;
let circles = []; // {el, timeoutId, startTime, lifeTimer}
let MAX_CIRCLES = 5;
let circleSize = 56;
let gameRunning = false;
let difficulty = 'medium';
let spawnLoop = null;
let countdownTimer = null;

/* Difficulty settings */
const DIFF = {
  easy:   { spawnInterval: 1400, timeLimit: 1400, maxCircles: 4 },
  medium: { spawnInterval: 1000, timeLimit: 1000, maxCircles: 5 },
  hard:   { spawnInterval: 700,  timeLimit: 800,  maxCircles: 6 }
};

/* Combo system */
let combo = 1;
let lastReaction = null;
let comboTimerId = null;
const COMBO_WINDOW = 550; // ms under which next tap increments combo
const COMBO_DECAY = 900;  // ms after which combo resets

/* Reaction times */
let reactionTimes = []; // array of ms
let avgRT = null;

/* Highscore storage keys */
const HS_KEY = 'nrt_best_score_v1';
const HS_AVG_KEY = 'nrt_best_avg_v1';

/* Neon palette */
const neonColors = ['#00fff7','#ff00ff','#00ff88','#ff0055','#55ffff','#ffaa00'];

/* ========== Helpers ========== */
function setHUD(){
  scoreEl.textContent = score;
  comboEl.textContent = 'x' + combo;
  const latest = reactionTimes.length ? Math.round(reactionTimes[reactionTimes.length-1]) : '--';
  const avg = reactionTimes.length ? Math.round(reactionTimes.reduce((a,b)=>a+b,0)/reactionTimes.length) : '--';
  rtEl.textContent = `${latest} / ${avg}`;
  avgRT = reactionTimes.length ? reactionTimes.reduce((a,b)=>a+b,0)/reactionTimes.length : null;
  const best = localStorage.getItem(HS_KEY);
  const bestAvg = localStorage.getItem(HS_AVG_KEY);
  bestLine.textContent = best ? `BEST: ${best} | AVG: ${bestAvg || '--'}ms` : 'BEST: --';
}

function playPop(){
  try {
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioCtx();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.setValueAtTime(700 - Math.random()*150, audioCtx.currentTime);
    g.gain.setValueAtTime(0.12, audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + 0.12);
    o.onended = ()=> audioCtx.close();
  } catch(e){}
}

/* Random non-overlapping placement */
function getRectOffset(){
  const rect = playArea.getBoundingClientRect();
  const left = rect.left; const top = rect.top;
  return { left, top };
}
function randomPos(size, existing){
  const pad = 8;
  const area = playArea.getBoundingClientRect();
  const maxX = area.width - size - pad;
  const maxY = area.height - size - pad;
  const x = Math.floor(Math.random() * Math.max(1, maxX)) + pad;
  const y = Math.floor(Math.random() * Math.max(1, maxY)) + pad;
  if(!existing) return {x,y};
  // check overlap with center distance (using size)
  for(const c of existing){
    const rect = c.el.getBoundingClientRect();
    const cx = rect.left - area.left;
    const cy = rect.top - area.top;
    const dx = cx + rect.width/2 - (x + size/2);
    const dy = cy + rect.height/2 - (y + size/2);
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist < size + 6) return null; // overlapping
  }
  return {x,y};
}
function findNonOverlap(size, existing){
  const maxAttempts = 60;
  let attempt = 0;
  while(attempt < maxAttempts){
    const pos = randomPos(size, existing);
    if(pos) return pos;
    attempt++;
  }
  // fallback: return some position even if overlapping
  return randomPos(size, null);
}

/* ========== Game Logic ========== */
function handleCircleClick(circleObj) {
  if (!gameRunning) return;
  const now = performance.now();
  const reactionTime = now - circleObj.startTime;
  reactionTimes.push(reactionTime);

  if (lastReaction && reactionTime < COMBO_WINDOW) {
    combo++;
  } else {
    combo = 1;
  }

  clearTimeout(comboTimerId);
  comboTimerId = setTimeout(() => {
    combo = 1;
    setHUD();
  }, COMBO_DECAY);

  lastReaction = reactionTime;

  score += 10 + (combo * 5);

  for (let i = 0; i < 20; i++) {
    bursts.push(new BurstParticle(
      circleObj.el.offsetLeft + circleSize / 2,
      circleObj.el.offsetTop + circleSize / 2,
      circleObj.color
    ));
  }

  playPop();
  removeCircle(circleObj);
  setHUD();
}

function handleMiss(circleObj) {
  if (!gameRunning) return;
  combo = 1;
  score -= 5;
  if(score < 0) score = 0;
  removeCircle(circleObj);
  setHUD();
  if (circles.length >= DIFF[difficulty].maxCircles) {
    gameOver();
  }
}

function removeCircle(circleObj) {
  clearTimeout(circleObj.timeoutId);
  if (circleObj.el) {
    circleObj.el.remove();
  }
  circles = circles.filter(c => c !== circleObj);
  setHUD();
}

function createCircle() {
  if (!gameRunning) return;
  if (circles.length >= MAX_CIRCLES) return;

  const el = document.createElement('div');
  el.className = 'circle';
  el.style.width = circleSize + 'px';
  el.style.height = circleSize + 'px';
  const color = neonColors[Math.floor(Math.random() * neonColors.length)];
  el.style.background = `radial-gradient(circle at center, ${color}, #001616 70%)`;
  el.style.boxShadow = `0 0 12px ${color}, 0 0 30px ${color}`;
  playArea.appendChild(el);

  const pos = findNonOverlap(circleSize, circles);
  el.style.left = pos.x + 'px';
  el.style.top = pos.y + 'px';

  const circleObj = { el, timeoutId: null, startTime: performance.now(), color };

  // Event listener for taps and clicks
  const clickHandler = (e) => {
    e.stopPropagation();
    handleCircleClick(circleObj);
  };
  el.addEventListener('pointerdown', clickHandler, { once: true });
  el.addEventListener('contextmenu', e => e.preventDefault());

  const timeoutId = setTimeout(() => {
    handleMiss(circleObj);
  }, DIFF[difficulty].timeLimit);

  circleObj.timeoutId = timeoutId;
  circles.push(circleObj);
}


/* ========== Game Flow ========== */
function startGame() {
  score = 0;
  combo = 1;
  reactionTimes = [];
  lastReaction = null;
  clearTimeout(comboTimerId);
  circles.forEach(c => removeCircle(c));
  circles = [];

  gameRunning = true;
  loadingOverlay.style.display = 'none';
  gameoverOverlay.style.display = 'none';

  MAX_CIRCLES = DIFF[difficulty].maxCircles;

  spawnLoop = setInterval(createCircle, DIFF[difficulty].spawnInterval);
  setHUD();
}

function gameOver() {
  gameRunning = false;
  clearInterval(spawnLoop);
  clearTimeout(comboTimerId);
  circles.forEach(c => clearTimeout(c.timeoutId));

  const finalScore = score;
  const finalAvg = avgRT;

  // Update highscores
  const currentBest = parseFloat(localStorage.getItem(HS_KEY)) || 0;
  if (finalScore > currentBest) {
    localStorage.setItem(HS_KEY, finalScore);
  }
  const currentBestAvg = parseFloat(localStorage.getItem(HS_AVG_KEY));
  if (finalAvg && (isNaN(currentBestAvg) || finalAvg < currentBestAvg)) {
    localStorage.setItem(HS_AVG_KEY, Math.round(finalAvg));
  }

  const finalStatsEl = document.getElementById('final-stats');
  const scoreText = `Score: ${finalScore}`;
  const avgText = `Avg RT: ${finalAvg ? Math.round(finalAvg) : '--'}ms`;
  finalStatsEl.innerHTML = `${scoreText} <br/> ${avgText}`;

  gameoverOverlay.style.display = 'flex';
  setHUD();
}

function startCountdown() {
  loadingOverlay.style.display = 'none';
  countdownText.style.display = 'flex';
  let count = 3;
  countdownText.textContent = count;

  countdownTimer = setInterval(() => {
    count--;
    countdownText.textContent = count;
    if (count <= 0) {
      clearInterval(countdownTimer);
      countdownText.style.display = 'none';
      startGame();
    }
  }, 1000);
}

function returnToMenu() {
  // Stop the game if it's running
  if (gameRunning) {
    gameOver(); // This will handle all stopping logic
  }

  // Clear any existing countdown
  if (countdownTimer) {
    clearInterval(countdownTimer);
    countdownText.style.display = 'none';
  }

  // Clear all circles from the screen
  circles.forEach(c => removeCircle(c));
  circles = [];

  // Hide all overlays except the loading screen
  gameoverOverlay.style.display = 'none';
  loadingOverlay.style.display = 'flex';
}

function requestFullScreen(){
  const element = document.documentElement;
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }
}

/* ========== Event Listeners ========== */
startBtn.addEventListener('click', () => {
  requestFullScreen();
  startCountdown();
});

restartBtn.addEventListener('click', () => {
  startCountdown();
});

backBtn.addEventListener('click', () => {
  gameoverOverlay.style.display = 'none';
  loadingOverlay.style.display = 'flex';
});

// New listener for the return button in the HUD
returnBtn.addEventListener('click', returnToMenu);


difficultyRow.addEventListener('click', (e) => {
  if (e.target.tagName === 'BUTTON') {
    document.querySelectorAll('.difficulty-row .btn').forEach(btn => {
      btn.classList.add('ghost');
      btn.style.background = '';
      btn.style.color = '';
    });
    e.target.classList.remove('ghost');
    e.target.style.background = e.target.dataset.diff === 'medium' ? 'var(--accent-2)' : 'var(--accent)';
    e.target.style.color = '#022';
    difficulty = e.target.dataset.diff;
  }
});

// Initial HUD setup
setHUD();
</script>
</body>
</html>
